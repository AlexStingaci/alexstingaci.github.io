<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Homework 7 (Interactive) ¬∑ Security Random Walks ‚Äî Simulation & Binomial Convergence</title>
  <style>
  :root{
    --ink:#0f172a; --muted:#64748b; --line:#e2e8f0; --bg:#ffffff; --panel:#f8fafc;
    --accent:#2563eb; --accent-2:#60a5fa; --grid:#e5e7eb; --p-line:#ef4444;
  }
  *{box-sizing:border-box}
  body{ margin:0; color:var(--ink); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial; line-height:1.6; background:var(--bg) }
  .wrap{max-width:1100px; margin:32px auto 64px; padding:0 16px;}
  header h1{margin:0 0 6px; font-size:clamp(22px,3.5vw,34px);}
  header p.subtitle{margin:0; color:var(--muted);}
  .card{ border:1px solid var(--line); border-radius:14px; padding:16px; background:white }
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  .pill{display:inline-flex; gap:6px; align-items:center;  border:1px solid var(--line); padding:4px 10px; border-radius:999px; font-size:12px; color:var(--muted)}
  .intro{  border:1px solid var(--line); border-radius:12px; padding:16px; background:var(--panel) }
  .kpi{ display:flex; flex-wrap:wrap; gap:8px; margin:6px 0 }
  .cmp-grid{ display:grid; gap:14px }
  @media (min-width: 800px){ .cmp-grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); } }
  .cmp{  border:1px solid var(--line); border-radius:12px; padding:12px; background:white }
  .cmp h4{ margin:0 0 6px; font-size:16px }
  .callout{ border-left:4px solid var(--accent); padding:8px 12px;  border-radius:12px; border:1px solid var(--line); background:white }
  .small{ font-size: 13px; color: var(--muted) }
  .tbl{ width:100%; border-collapse:collapse; margin:10px 0;  border:1px solid var(--line); border-radius:12px; overflow:hidden; font-size:14px }
  .tbl th,.tbl td{ text-align:left; padding:8px 6px; border-bottom:1px solid var(--line) }
  .tbl th{ color:#111827; font-weight:600; }
  .controls{ display:grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap:8px; }
  @media (max-width: 900px){ .controls{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
  .control{ border:1px solid var(--line); border-radius:10px; padding:10px; background:white }
  .control label{ display:block; font-size:12px; color:var(--muted) }
  .control input{ width:100%; font: inherit; padding:6px 8px; border:1px solid var(--line); border-radius:8px }
  button.primary{ background:var(--accent); color:white; border:none; border-radius:10px; padding:10px 14px; font-weight:600; cursor:pointer }
  button.ghost{ background:white; color:var(--accent); border:1px solid var(--accent); border-radius:10px; padding:10px 14px; font-weight:600; cursor:pointer }
  .charts{ display:grid; gap:16px; }
  @media (min-width: 950px){ .charts{ grid-template-columns: 1.2fr 1fr; } }
  canvas{ width:100%; height:auto; background:white; border:1px solid var(--line); border-radius:12px }
  .legend{ display:flex; gap:8px; align-items:center; font-size:13px; color:var(--muted) }
  .legend .dot{ width:12px; height:12px; border-radius:50%; display:inline-block; outline:1px solid var(--line) }
  .dot.sim{ background:#f59e0b }
  .dot.exp{ background:#60a5fa }
  .muted{ color:var(--muted) }
  </style>
  <script>
  // ------- RNG (seeded) -------
  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  // ------- Binomial PMF via recurrence (numeric stable) -------
  function binomPMFArray(n, q){
    const pmf = new Float64Array(n+1);
    const one_m_q = 1 - q;
    pmf[0] = Math.pow(one_m_q, n);
    for(let k=0;k<n;k++){
      pmf[k+1] = pmf[k] * (n - k) / (k + 1) * (q / one_m_q);
    }
    return pmf;
  }

  // ------- Drawing helpers (Canvas 2D) -------
  function clearCanvas(ctx, w, h){
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,w,h);
  }
  function drawAxes(ctx, w, h, padding){
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding, h - padding);
    ctx.lineTo(w - padding, h - padding);
    ctx.lineTo(w - padding, padding);
    ctx.stroke();
  }
  function drawBarSeries(ctx, xs, ys, xscale, yscale, padding, color){
    ctx.fillStyle = color;
    const barw = Math.max(1, Math.floor(xscale.step - 1));
    for(let i=0;i<xs.length;i++){
      const x = padding + xscale.map(xs[i]) - barw/2;
      const y = yscale(ys[i]);
      const y0 = yscale(0);
      const height = y0 - y;
      ctx.fillRect(x, y, barw, height);
    }
  }
  function drawLineSeries(ctx, xs, ys, xscale, yscale, padding, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const x = padding + xscale.map(xs[i]);
      const y = yscale(ys[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  function makeLinearScale(domainMin, domainMax, rangeMin, rangeMax){
    const span = domainMax - domainMin || 1;
    const scale = (v)=> rangeMin + (v - domainMin) * (rangeMax - rangeMin) / span;
    scale.step = (rangeMax - rangeMin) / Math.max(1,(domainMax - domainMin));
    return scale;
  }
  function yScale(maxY, h, padding){
    const ymin = 0, ymax = maxY*1.05 + 1e-9;
    const scale = (v)=> {
      return h - padding - (v - ymin) * (h - 2*padding) / (ymax - ymin);
    };
    return scale;
  }

  // ------- Simulation -------
  function simulate(params){
    const {n, m, p, T, seed, sampleK} = params;
    const rng = mulberry32(seed >>> 0);
    const q = 1 - Math.pow(1 - p, m);
    const finalScores = new Int32Array(T);
    const samplePaths = [];
    const maxK = Math.min(sampleK, T);

    for(let t=0; t<T; t++){
      let score=0;
      let path = (t<maxK) ? new Int16Array(n) : null;
      for(let i=0;i<n;i++){
        // Bernoulli(q): breach -> -1, secure -> +1
        const step = (rng()<q) ? -1 : 1;
        score += step;
        if(path) path[i] = score;
      }
      finalScores[t] = score;
      if(path) samplePaths.push(path);
    }

    // Count simulated frequencies over possible scores s=n,n-2,...,-n
    const possibleScores = [];
    for(let s=n; s>=-n; s-=2) possibleScores.push(s);

    const simCounts = new Float64Array(possibleScores.length);
    for(let t=0; t<T; t++){
      const s = finalScores[t];
      const idx = (n - s)/2; // idx corresponds to number of breached weeks B
      simCounts[idx] += 1;
    }
    const simProbs = simCounts.map ? simCounts.map(v => v/T) : Array.from(simCounts, v=>v/T);

    // Theory from Binomial(n,q) on B, then map to S_n = n - 2B
    const pmfB = binomPMFArray(n, q); // length n+1 for B=0..n
    const theoryProbs = Array.from(pmfB); // same index mapping

    // Total Variation Distance
    let tv = 0;
    for(let i=0;i<theoryProbs.length;i++){
      tv += Math.abs(simProbs[i] - theoryProbs[i]);
    }
    tv *= 0.5;

    return { q, finalScores, samplePaths, possibleScores, simCounts, simProbs, theoryProbs, tv };
  }

  // ------- UI glue -------
  function getParams(){
    const n = Math.max(1, Math.floor(Number(document.getElementById('n').value)));
    const m = Math.max(0, Math.floor(Number(document.getElementById('m').value)));
    let p = Number(document.getElementById('p').value);
    p = Math.min(1, Math.max(0, p));
    const T = Math.max(1, Math.floor(Number(document.getElementById('T').value)));
    const seed = Math.floor(Number(document.getElementById('seed').value)) || 1;
    const sampleK = Math.max(1, Math.floor(Number(document.getElementById('k').value)));
    return {n,m,p,T,seed,sampleK};
  }

  function format(num, digits=6){
    return Number(num).toFixed(digits);
  }

  function renderCountsTable(possibleScores, simCounts, simProbs, theoryProbs, n){
    const tbody = document.querySelector('#counts-body');
    tbody.innerHTML='';
    for(let i=0;i<possibleScores.length;i++){
      const s = possibleScores[i];
      const b = (n - s)/2;
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${s}</td><td>${b}</td><td>${Math.round(simCounts[i])}</td><td>${format(simProbs[i])}</td><td>${format(theoryProbs[i])}</td>`;
      tbody.appendChild(tr);
    }
  }

  function makeCountsCSV(possibleScores, simCounts, simProbs, theoryProbs, n){
    const header = ["score","breached_weeks_b","sim_count","sim_prob","theory_prob"];
    const rows = [header.join(",")];
    for(let i=0;i<possibleScores.length;i++){
      const s = possibleScores[i];
      const b = (n - s)/2;
      rows.push([s,b,Math.round(simCounts[i]),simProbs[i],theoryProbs[i]].join(","));
    }
    return rows.join("\n");
  }

  function downloadCSV(content, filename){
    const blob = new Blob([content], {type:"text/csv;charset=utf-8;"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  function drawTrajectories(canvas, samplePaths){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height, padding = 30;
    clearCanvas(ctx, w, h);
    drawAxes(ctx, w, h, padding);
    // y scale: compute min/max from paths
    let ymin=0, ymax=0;
    for(const path of samplePaths){
      for(let v of path){ if(v<ymin) ymin=v; if(v>ymax) ymax=v; }
    }
    if(ymin===ymax){ ymin-=1; ymax+=1; }
    const xScale = makeLinearScale(1, samplePaths[0]?.length || 1, padding, w - padding);
    const yScale = (v)=>{
      return h - padding - (v - ymin) * (h - 2*padding) / (ymax - ymin);
    };
    // draw lines
    ctx.lineWidth = 1.5;
    for(const path of samplePaths){
      ctx.beginPath();
      ctx.strokeStyle = '#0ea5e9';
      for(let i=0;i<path.length;i++){
        const x = xScale(i+1);
        const y = yScale(path[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    // labels
    ctx.fillStyle = '#111827';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Week', w - padding - 28, h - 8);
    ctx.save(); ctx.translate(12, padding + 30); ctx.rotate(-Math.PI/2); ctx.fillText('Cumulative score', 0,0); ctx.restore();
  }

  function drawCountsChart(canvas, possibleScores, simCounts, expectedCounts){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height, padding = 40;
    clearCanvas(ctx, w, h); drawAxes(ctx, w, h, padding);
    const xs = possibleScores.slice().reverse(); // ascending for nicer mapping
    const sim = Array.from(simCounts).slice().reverse();
    const exp = Array.from(expectedCounts).slice().reverse();
    const maxY = Math.max(...sim, ...exp, 1);
    const xScale = {
      map:(v)=>{
        // map xs (ascending) to [padding, w - padding]
        const idx = xs.indexOf(v);
        const step = (w - 2*padding) / Math.max(1, xs.length-1);
        const x0 = padding;
        return x0 + idx * step;
      },
      step: (w - 2*padding)/Math.max(1,xs.length-1)
    };
    const yScale = yScaleCounts(maxY, h, padding);
    function yScaleCounts(maxY, h, padding){
      const ymin = 0, ymax = maxY*1.05 + 1e-9;
      return (v)=> h - padding - (v - ymin) * (h - 2*padding) / (ymax - ymin);
    }
    // bars (sim)
    drawBarSeries(ctx, xs, sim, xScale, yScale, padding, '#f59e0b');
    // line (expected)
    drawLineSeries(ctx, xs, exp, xScale, yScale, padding, '#60a5fa');
    // legend
    ctx.fillStyle = '#64748b';
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText('Simulated counts', padding, 18);
    ctx.fillStyle = '#f59e0b'; ctx.fillRect(padding-16, 10, 10, 10);
    ctx.fillStyle = '#64748b'; ctx.fillText('Expected (Binomial)', padding+150, 18);
    ctx.strokeStyle = '#60a5fa'; ctx.beginPath(); ctx.moveTo(padding+130, 15); ctx.lineTo(padding+146, 15); ctx.stroke();
    // axis labels
    ctx.fillStyle = '#111827';
    ctx.fillText('Total score after n weeks', w/2 - 60, h - 8);
    ctx.save(); ctx.translate(12, h/2); ctx.rotate(-Math.PI/2); ctx.fillText('Count', 0,0); ctx.restore();
  }

  function drawResiduals(canvas, possibleScores, simCounts, expectedCounts){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height, padding = 40;
    clearCanvas(ctx, w, h); drawAxes(ctx, w, h, padding);
    const xs = possibleScores.slice().reverse();
    const resid = Array.from(simCounts).map((v,i)=> v - expectedCounts[i]).slice().reverse();
    const maxAbs = Math.max(...resid.map(Math.abs), 1);
    const xScale = {
      map:(v)=>{
        const idx = xs.indexOf(v);
        const step = (w - 2*padding) / Math.max(1, xs.length-1);
        return padding + idx * step;
      },
      step: (w - 2*padding)/Math.max(1,xs.length-1)
    };
    const yScale = (v)=>{
      const ymin = -maxAbs*1.1, ymax = maxAbs*1.1;
      return h - padding - (v - ymin)*(h - 2*padding)/(ymax - ymin);
    };
    // bars
    ctx.fillStyle = '#a78bfa';
    const barw = Math.max(1, Math.floor(xScale.step - 1));
    for(let i=0;i<xs.length;i++){
      const x = padding + xScale.map(xs[i]) - barw/2;
      const y = yScale(resid[i]);
      const y0 = yScale(0);
      const ht = y0 - y;
      ctx.fillRect(x, y, barw, ht);
    }
    // labels
    ctx.fillStyle = '#111827';
    ctx.fillText('Residual (sim - expected)', w/2 - 70, h - 8);
  }

  function run(){
    const params = getParams();
    const {n,m,p,T,seed,sampleK} = params;
    const res = simulate(params);
    const {q, samplePaths, possibleScores, simCounts, simProbs, theoryProbs, tv} = res;
    const expectedCounts = theoryProbs.map(tp => tp * T);

    // Update KPIs
    document.getElementById('q').textContent = format(q, 6);
    document.getElementById('tv').textContent = format(tv, 6);
    document.getElementById('summary').textContent = `n=${n}, m=${m}, p=${p} ‚áí weekly breach q=${format(q,6)}; trajectories T=${T}`;

    // Draw charts
    drawTrajectories(document.getElementById('traj'), samplePaths);
    drawCountsChart(document.getElementById('counts'), possibleScores, simCounts, expectedCounts);
    drawResiduals(document.getElementById('resid'), possibleScores, simCounts, expectedCounts);

    // Fill counts table
    renderCountsTable(possibleScores, simCounts, simProbs, theoryProbs, n);

    // Setup CSV download
    const csv = makeCountsCSV(possibleScores, simCounts, simProbs, theoryProbs, n);
    document.getElementById('dlCounts').onclick = ()=> downloadCSV(csv, 'hw7_counts_dynamic.csv');
  }

  window.addEventListener('DOMContentLoaded', ()=>{
    document.getElementById('run').addEventListener('click', run);
    // sensible defaults
    run();
  });
  </script>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Security Random Walks ‚Äî Interactive Simulation</h1>
      <p class="subtitle">Change parameters and regenerate trajectories, counts, and binomial comparison.</p>
    </header>

    <section class="intro" style="margin-top:12px">
      <div class="kpi">
        <span class="pill">Weekly breach: <code>q = 1 - (1-p)^m</code></span>
        <span class="pill">Random walk: <code>S_n = Œ£ X_i</code>, <code>X_i‚àà{+1,-1}</code></span>
        <span class="pill">Mapping: <code>S_n = n - 2B</code>, <code>B ~ Bin(n,q)</code></span>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="control"><label>n (weeks)</label><input id="n" type="number" value="52" min="1" step="1"></div>
        <div class="control"><label>m (attackers/week)</label><input id="m" type="number" value="10" min="0" step="1"></div>
        <div class="control"><label>p (per-attacker breach)</label><input id="p" type="number" value="0.05" min="0" max="1" step="0.001"></div>
        <div class="control"><label>T (trajectories)</label><input id="T" type="number" value="20000" min="1" step="1000"></div>
        <div class="control"><label>seed</label><input id="seed" type="number" value="42" step="1"></div>
        <div class="control"><label>sample trajectories (K)</label><input id="k" type="number" value="25" min="1" step="1"></div>
        <button id="run" class="primary" style="margin-left:auto">Run simulation</button>
      </div>
      <p class="small muted" id="summary"></p>
      <div class="kpi">
        <span class="pill">Computed q: <strong id="q">‚Äî</strong></span>
        <span class="pill">Total variation distance: <strong id="tv">‚Äî</strong></span>
      </div>
    </section>

    <section class="card" style="margin-top:16px">
      <h2>Trajectories (random walk)</h2>
      <canvas id="traj" width="800" height="320"></canvas>
      <p class="small muted">Lines show K sample cumulative-score paths over n weeks.</p>
    </section>

    <section class="card" style="margin-top:16px">
      <h2>Distribution of total scores: simulation vs binomial</h2>
      <div class="legend"><span class="dot sim"></span> Simulated counts &nbsp; <span class="dot exp"></span> Expected counts (Binomial-induced)</div>
      <canvas id="counts" width="800" height="360"></canvas>
      <p class="small muted">We map the binomial on breached weeks \(B\sim Bin(n,q)\) to scores via \(S_n=n-2B\).</p>
      <div class="row">
        <button id="dlCounts" class="ghost">Download counts CSV</button>
      </div>
      <table class="tbl">
        <thead><tr><th>score s</th><th>b = (n-s)/2</th><th>sim count</th><th>sim prob</th><th>theory prob</th></tr></thead>
        <tbody id="counts-body"></tbody>
      </table>
    </section>

    <section class="card" style="margin-top:16px">
      <h2>Residuals (simulated ‚àí expected counts)</h2>
      <canvas id="resid" width="800" height="320"></canvas>
    </section>

  
    <article class="card">
      <h2 id="logic"><a class="anchor" href="#logic">Theory & Logic (English)</a></h2>
      <div class="cmp-grid">
        <div class="cmp">
          <h4>Model & Random-Walk Mapping</h4>
          <ul>
            <li><strong>Weekly breach probability.</strong> With <em>m</em> independent attackers each succeeding with probability <em>p</em>, a breach in a given week occurs with
              <span class="pill">q = 1 - (1-p)^m</span>.</li>
            <li><strong>Steps.</strong> Define weekly steps <code>X_i ‚àà {+1, ‚àí1}</code>, where <code>X_i=+1</code> if the server stays secure and <code>X_i=‚àí1</code> if breached. Then
              <code>‚Ñô(X_i=+1)=1‚àíq</code>, <code>‚Ñô(X_i=‚àí1)=q</code>, and the cumulative score is the biased random walk <span class="pill">S_n = Œ£_{i=1}^n X_i</span>.</li>
            <li><strong>Binomial correspondence.</strong> Let <code>B = # { i ‚â§ n : X_i = ‚àí1 }</code> be the number of breached weeks. Then <code>B ‚àº Bin(n, q)</code> and
              <span class="pill">S_n = n ‚àí 2B</span>. Consequently,
              <code>‚Ñô(S_n = s) = C(n, (n‚àís)/2) q^{(n‚àís)/2} (1‚àíq)^{(n+s)/2}</code> for feasible <code>s ‚àà {n, n‚àí2, ‚Ä¶, ‚àín}</code>.</li>
          </ul>
        </div>
        <div class="cmp">
          <h4>Moments, Drift & Asymptotics</h4>
          <ul>
            <li><strong>Drift.</strong> <code>E[X_i] = (1‚àíq) ‚àí q = 1‚àí2q</code>; hence <code>E[S_n] = n(1‚àí2q)</code>.</li>
            <li><strong>Variance.</strong> <code>Var(X_i) = 4q(1‚àíq)</code>; hence <code>Var(S_n) = 4n q(1‚àíq)</code>.</li>
            <li><strong>CLT.</strong> As <em>n</em> grows, <code>(S_n ‚àí n(1‚àí2q)) / ‚àö(4n q(1‚àíq)) ‚áí ùìù(0,1)</code>, so the (properly standardized) distribution is approximately Gaussian.</li>
            <li><strong>Effect of m.</strong> <code>q = 1‚àí(1‚àíp)^m ‚âà 1 ‚àí e^{‚àímp}</code> for small <em>p</em>; increasing <em>m</em> raises <em>q</em> and pushes the random walk‚Äôs drift toward the negative side.</li>
          </ul>
        </div>
      </div>
      <div class="cmp-grid">
        <div class="cmp">
          <h4>Simulation Algorithm & Complexity</h4>
          <ol>
            <li>Compute <code>q</code>.</li>
            <li>For each trajectory t=1..T and week i=1..n: sample <code>breach ~ Bernoulli(q)</code>, set <code>step = ‚àí1</code> if breach else <code>+1</code>, and update the cumulative score.</li>
            <li>Record the final score and (optionally) the whole path for a small sample of trajectories.</li>
          </ol>
          <p class="small">Time complexity: <code>O(T¬∑n)</code>. Memory: <code>O(T)</code> to store final scores plus <code>O(K¬∑n)</code> if we keep K sample paths for plotting.</p>
        </div>
        <div class="cmp">
          <h4>Distribution Comparison & Convergence</h4>
          <ul>
            <li>Map final scores to <code>b = (n‚àís)/2</code> and compare simulated frequencies with the binomial probabilities <code>Bin(n,q)</code>.</li>
            <li><strong>Metrics.</strong> We report <em>Total Variation distance</em> <code>TV = ¬Ω Œ£ |pÃÇ_s ‚àí p_s|</code> and visualize residuals (simulated ‚àí expected counts).</li>
            <li>As <em>n</em> increases (and with enough trajectories), empirical frequencies approach the binomial-induced distribution. If <em>m</em> changes while <em>p</em> is fixed, convergence is measured at the corresponding <code>q</code>.</li>
          </ul>
          <p class="small">Numerical note: binomial probabilities are computed via a stable recurrence to avoid overflow/underflow for large n.</p>
        </div>
      </div>
    </article>
    
  </div>
</body>
</html>
